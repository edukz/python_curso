#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
M√≥dulo 15: Manipula√ß√£o de Arquivos
Aprenda a trabalhar com arquivos, persist√™ncia de dados e backup
"""

from ..shared.base_module import BaseModule


class Modulo15Datetime(BaseModule):
    """M√≥dulo 15: Manipula√ß√£o de Arquivos - Persist√™ncia de Dados"""
    
    def __init__(self):
        super().__init__("modulo_15", "Manipula√ß√£o de Arquivos")
        self.has_mini_project = True
        self.mini_project_points = 75
    
    def execute(self) -> None:
        """Executa o m√≥dulo sobre manipula√ß√£o de arquivos"""
        if not self.ui or not self.progress:
            print("‚ùå Erro: Depend√™ncias n√£o configuradas para este m√≥dulo")
            input("Pressione ENTER para continuar...")
            return
        
        try:
            self._arquivos()
        except Exception as e:
            self.error_handler(lambda: None)
    
    def _arquivos(self) -> None:
        """Conte√∫do principal sobre manipula√ß√£o de arquivos"""
        if self.ui:
            self.ui.clear_screen()
            self.ui.header("üìÅ M√ìDULO 15: MANIPULA√á√ÉO DE ARQUIVOS")
        else:
            print("\n" + "="*50)
            print("üìÅ M√ìDULO 15: MANIPULA√á√ÉO DE ARQUIVOS")
            print("="*50)
        
        print("üìÅ Agora vamos aprender a SALVAR e CARREGAR dados!")
        print("üíæ Arquivos s√£o fundamentais para guardar informa√ß√µes!")
        
        print("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print("        LENDO E ESCREVENDO ARQUIVOS")
        print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        
        print("\nüìù Modos de abertura:")
        print("‚Ä¢ 'r' - Leitura (read)")
        print("‚Ä¢ 'w' - Escrita (write) - APAGA o arquivo!")
        print("‚Ä¢ 'a' - Anexar (append) - adiciona no final")
        print("‚Ä¢ 'r+' - Leitura e escrita")
        
        self.pausar()
        
        # Escrevendo arquivos
        codigo1 = '''# Escrevendo arquivos
# M√©todo b√°sico
arquivo = open("teste.txt", "w", encoding="utf-8")
arquivo.write("Ol√°, mundo!\\n")
arquivo.write("Este √© meu primeiro arquivo em Python.\\n")
arquivo.close()

print("‚úÖ Arquivo 'teste.txt' criado!")

# M√©todo recomendado - with statement
with open("lista_compras.txt", "w", encoding="utf-8") as arquivo:
    compras = ["Arroz", "Feij√£o", "A√ß√∫car", "Caf√©", "Leite"]
    for item in compras:
        arquivo.write(f"- {item}\\n")

print("‚úÖ Lista de compras salva!")

# M√∫ltiplas linhas de uma vez
conteudo = """Este √© um arquivo de m√∫ltiplas linhas.
Linha 2 do arquivo.
Linha 3 com alguns dados.
Final do arquivo."""

with open("multiplas_linhas.txt", "w", encoding="utf-8") as arquivo:
    arquivo.write(conteudo)

print("‚úÖ Arquivo com m√∫ltiplas linhas criado!")'''
        
        self.exemplo(codigo1)
        self.executar_codigo(codigo1)
        
        self.pausar()
        
        print("\nüìñ Lendo arquivos:")
        
        codigo2 = '''# Lendo arquivos
print("=== LENDO ARQUIVO COMPLETO ===")
try:
    with open("teste.txt", "r", encoding="utf-8") as arquivo:
        conteudo = arquivo.read()
        print("Conte√∫do do arquivo:")
        print(conteudo)
except FileNotFoundError:
    print("‚ùå Arquivo n√£o encontrado! Vamos criar um.")
    with open("teste.txt", "w", encoding="utf-8") as arquivo:
        arquivo.write("Arquivo de exemplo\\nSegunda linha\\n")
    print("‚úÖ Arquivo criado. Lendo agora...")
    with open("teste.txt", "r", encoding="utf-8") as arquivo:
        print(arquivo.read())

print("\\n=== LENDO LINHA POR LINHA ===")
with open("teste.txt", "r", encoding="utf-8") as arquivo:
    linhas = arquivo.readlines()
    for i, linha in enumerate(linhas, 1):
        print(f"Linha {i}: {linha.strip()}")

print("\\n=== LENDO COM LOOP ===")
with open("teste.txt", "r", encoding="utf-8") as arquivo:
    for numero, linha in enumerate(arquivo, 1):
        print(f"{numero:02d}: {linha.rstrip()}")'''
        
        self.exemplo(codigo2)
        self.executar_codigo(codigo2)
        
        self.pausar()
        
        print("\nüíº Exemplo Pr√°tico - Sistema de Cadastro:")
        
        codigo3 = '''# Sistema de cadastro em arquivo
import json
from datetime import datetime

def salvar_pessoa(nome, idade, email):
    """Salva dados de uma pessoa no arquivo"""
    pessoa = {
        "nome": nome,
        "idade": idade,
        "email": email,
        "cadastrado_em": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    # L√™ pessoas existentes
    try:
        with open("pessoas.json", "r", encoding="utf-8") as arquivo:
            pessoas = json.load(arquivo)
    except FileNotFoundError:
        pessoas = []
    
    # Adiciona nova pessoa
    pessoas.append(pessoa)
    
    # Salva tudo de volta
    with open("pessoas.json", "w", encoding="utf-8") as arquivo:
        json.dump(pessoas, arquivo, indent=2, ensure_ascii=False)
    
    print(f"‚úÖ {nome} cadastrado com sucesso!")

def listar_pessoas():
    """Lista todas as pessoas cadastradas"""
    try:
        with open("pessoas.json", "r", encoding="utf-8") as arquivo:
            pessoas = json.load(arquivo)
        
        print("\\n=== PESSOAS CADASTRADAS ===")
        for i, pessoa in enumerate(pessoas, 1):
            print(f"{i}. {pessoa['nome']} ({pessoa['idade']} anos)")
            print(f"   Email: {pessoa['email']}")
            print(f"   Cadastrado em: {pessoa['cadastrado_em']}")
            print()
    except FileNotFoundError:
        print("‚ùå Nenhuma pessoa cadastrada ainda.")

# Testando o sistema
salvar_pessoa("Jo√£o Silva", 30, "joao@email.com")
salvar_pessoa("Maria Santos", 25, "maria@email.com")
salvar_pessoa("Pedro Costa", 35, "pedro@email.com")

listar_pessoas()'''
        
        self.exemplo(codigo3)
        self.executar_codigo(codigo3)
        
        self.pausar()
        
        print("\nüõ°Ô∏è Tratamento de Erros com Arquivos:")
        
        codigo4 = '''# Tratamento robusto de erros
def ler_arquivo_seguro(nome_arquivo):
    """L√™ arquivo com tratamento completo de erros"""
    try:
        with open(nome_arquivo, "r", encoding="utf-8") as arquivo:
            return arquivo.read()
    except FileNotFoundError:
        print(f"‚ùå Arquivo '{nome_arquivo}' n√£o encontrado!")
        return None
    except PermissionError:
        print(f"‚ùå Sem permiss√£o para ler '{nome_arquivo}'!")
        return None
    except UnicodeDecodeError:
        print(f"‚ùå Erro de codifica√ß√£o no arquivo '{nome_arquivo}'!")
        return None
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        return None

def escrever_log(mensagem):
    """Escreve no arquivo de log com timestamp"""
    from datetime import datetime
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    linha_log = f"[{timestamp}] {mensagem}\\n"
    
    try:
        with open("sistema.log", "a", encoding="utf-8") as arquivo:
            arquivo.write(linha_log)
        print(f"üìù Log registrado: {mensagem}")
    except Exception as e:
        print(f"‚ùå Erro ao escrever log: {e}")

# Testando
conteudo = ler_arquivo_seguro("teste.txt")
if conteudo:
    print("Arquivo lido com sucesso!")

escrever_log("Sistema iniciado")
escrever_log("Usu√°rio fez login")
escrever_log("Arquivo processado")

# Lendo o log
print("\\n=== CONTE√öDO DO LOG ===")
log_content = ler_arquivo_seguro("sistema.log")
if log_content:
    print(log_content)'''
        
        self.exemplo(codigo4)
        self.executar_codigo(codigo4)
        
        # Exerc√≠cios
        self.exercicio(
            "Qual √© a forma mais segura de abrir arquivos em Python?",
            ["with open", "with statement", "context manager"],
            "Use 'with' para fechar automaticamente"
        )
        
        self.exercicio(
            "Que modo usar para adicionar texto no final de um arquivo?",
            ["'a'", "append", "modo append"],
            "Modo 'a' adiciona no final sem apagar"
        )
        
        # Mini Projeto do M√≥dulo 15
        self._mini_projeto_backup_inteligente()
        
        # Marcar m√≥dulo como completo
        self.complete_module()
    
    def _mini_projeto_backup_inteligente(self) -> None:
        """Mini Projeto - M√≥dulo 15: Sistema de Backup Inteligente"""
        if self.ui:
            self.ui.clear_screen()
            self.ui.header("üéØ MINI PROJETO: SISTEMA DE BACKUP INTELIGENTE")
        else:
            print("\n" + "="*50)
            print("üéØ MINI PROJETO: SISTEMA DE BACKUP INTELIGENTE")
            print("="*50)
        
        print("üíæ Sistema completo de backup com compress√£o e versionamento!")
        print("üõ†Ô∏è Usando: Manipula√ß√£o de Arquivos, JSON, CSV, ZIP, Diret√≥rios")
        
        self.pausar()
        
        codigo_projeto = '''# üíæ SISTEMA DE BACKUP INTELIGENTE
# Projeto completo de backup com versionamento e compress√£o

import os
import json
import csv
import zipfile
import shutil
from datetime import datetime, timedelta
import hashlib
from pathlib import Path

class SistemaBackupInteligente:
    def __init__(self, diretorio_backup="backups"):
        self.diretorio_backup = Path(diretorio_backup)
        self.config_file = self.diretorio_backup / "backup_config.json"
        self.log_file = self.diretorio_backup / "backup_log.csv"
        self.metadata_file = self.diretorio_backup / "metadata.json"
        
        # Criar diret√≥rio se n√£o existir
        self.diretorio_backup.mkdir(exist_ok=True)
        
        # Configura√ß√µes padr√£o
        self.config = {
            "max_versoes": 5,
            "compressao_ativa": True,
            "backup_automatico": False,
            "tipos_arquivo_incluir": [".py", ".txt", ".json", ".csv", ".md"],
            "pastas_ignorar": ["__pycache__", ".git", "node_modules", ".vscode"],
            "tamanho_max_arquivo_mb": 10
        }
        
        self.carregar_configuracao()
        self.inicializar_log()
    
    def carregar_configuracao(self):
        """Carrega configura√ß√£o do arquivo JSON"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config_carregada = json.load(f)
                    self.config.update(config_carregada)
                print("‚úÖ Configura√ß√£o carregada")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao carregar config: {e}")
        else:
            self.salvar_configuracao()
    
    def salvar_configuracao(self):
        """Salva configura√ß√£o atual em JSON"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            print("‚úÖ Configura√ß√£o salva")
        except Exception as e:
            print(f"‚ùå Erro ao salvar config: {e}")
    
    def inicializar_log(self):
        """Inicializa arquivo de log CSV"""
        if not self.log_file.exists():
            with open(self.log_file, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    'timestamp', 'operacao', 'origem', 'destino', 
                    'arquivos_processados', 'tamanho_total', 'status', 'observacoes'
                ])
    
    def registrar_log(self, operacao, origem, destino, arquivos, tamanho, status, obs=""):
        """Registra opera√ß√£o no log CSV"""
        try:
            with open(self.log_file, 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow([
                    datetime.now().isoformat(),
                    operacao,
                    str(origem),
                    str(destino),
                    arquivos,
                    tamanho,
                    status,
                    obs
                ])
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao registrar log: {e}")
    
    def calcular_hash_arquivo(self, caminho_arquivo):
        """Calcula hash MD5 de um arquivo"""
        hash_md5 = hashlib.md5()
        try:
            with open(caminho_arquivo, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception:
            return None
    
    def deve_incluir_arquivo(self, caminho_arquivo):
        """Verifica se arquivo deve ser inclu√≠do no backup"""
        arquivo_path = Path(caminho_arquivo)
        
        # Verifica extens√£o
        if self.config["tipos_arquivo_incluir"]:
            if arquivo_path.suffix not in self.config["tipos_arquivo_incluir"]:
                return False
        
        # Verifica tamanho
        try:
            tamanho_mb = arquivo_path.stat().st_size / (1024 * 1024)
            if tamanho_mb > self.config["tamanho_max_arquivo_mb"]:
                return False
        except:
            return False
        
        # Verifica se est√° em pasta ignorada
        for pasta_ignorar in self.config["pastas_ignorar"]:
            if pasta_ignorar in str(arquivo_path):
                return False
        
        return True
    
    def escanear_diretorio(self, caminho_origem):
        """Escaneia diret√≥rio e retorna lista de arquivos v√°lidos"""
        origem_path = Path(caminho_origem)
        
        if not origem_path.exists():
            print(f"‚ùå Diret√≥rio n√£o existe: {caminho_origem}")
            return []
        
        arquivos_validos = []
        total_arquivos = 0
        
        print(f"üîç Escaneando: {caminho_origem}")
        
        for arquivo in origem_path.rglob("*"):
            if arquivo.is_file():
                total_arquivos += 1
                
                if self.deve_incluir_arquivo(arquivo):
                    arquivos_validos.append(arquivo)
        
        print(f"üìä Encontrados: {len(arquivos_validos)}/{total_arquivos} arquivos v√°lidos")
        return arquivos_validos
    
    def criar_backup(self, caminho_origem, nome_backup=None):
        """Cria backup de um diret√≥rio"""
        if nome_backup is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            nome_backup = f"backup_{timestamp}"
        
        print(f"\\nüöÄ Iniciando backup: {nome_backup}")
        
        # Escanear arquivos
        arquivos = self.escanear_diretorio(caminho_origem)
        if not arquivos:
            print("‚ùå Nenhum arquivo para backup")
            return False
        
        # Criar diret√≥rio de vers√£o
        versao_dir = self.diretorio_backup / nome_backup
        versao_dir.mkdir(exist_ok=True)
        
        arquivos_copiados = 0
        tamanho_total = 0
        arquivos_com_erro = []
        
        # Copiar arquivos
        print("üìÅ Copiando arquivos...")
        for arquivo_origem in arquivos:
            try:
                # Manter estrutura de diret√≥rios
                rel_path = arquivo_origem.relative_to(Path(caminho_origem))
                arquivo_destino = versao_dir / rel_path
                
                # Criar diret√≥rio pai se necess√°rio
                arquivo_destino.parent.mkdir(parents=True, exist_ok=True)
                
                # Copiar arquivo
                shutil.copy2(arquivo_origem, arquivo_destino)
                
                arquivos_copiados += 1
                tamanho_total += arquivo_origem.stat().st_size
                
                if arquivos_copiados % 10 == 0:
                    print(f"  üìÅ Copiados: {arquivos_copiados}/{len(arquivos)}")
                
            except Exception as e:
                arquivos_com_erro.append(f"{arquivo_origem}: {e}")
        
        # Criar metadata
        metadata = {
            "nome_backup": nome_backup,
            "timestamp": datetime.now().isoformat(),
            "origem": str(caminho_origem),
            "arquivos_total": len(arquivos),
            "arquivos_copiados": arquivos_copiados,
            "tamanho_bytes": tamanho_total,
            "arquivos_com_erro": arquivos_com_erro,
            "hash_backup": self.calcular_hash_diretorio(versao_dir)
        }
        
        # Salvar metadata
        metadata_path = versao_dir / "backup_metadata.json"
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
        
        # Compress√£o se ativada
        if self.config["compressao_ativa"]:
            print("üóúÔ∏è Comprimindo backup...")
            zip_path = versao_dir.with_suffix('.zip')
            self.comprimir_diretorio(versao_dir, zip_path)
            
            # Remove diret√≥rio original ap√≥s compress√£o
            shutil.rmtree(versao_dir)
            
            # Atualiza tamanho comprimido
            metadata["tamanho_comprimido"] = zip_path.stat().st_size
            metadata["comprimido"] = True
        
        # Registrar no log
        status = "SUCESSO" if not arquivos_com_erro else "SUCESSO_COM_ERROS"
        obs = f"{len(arquivos_com_erro)} erros" if arquivos_com_erro else ""
        
        self.registrar_log(
            "BACKUP",
            caminho_origem,
            nome_backup,
            arquivos_copiados,
            tamanho_total,
            status,
            obs
        )
        
        print(f"\\n‚úÖ Backup conclu√≠do!")
        print(f"üìä Arquivos: {arquivos_copiados}/{len(arquivos)}")
        print(f"üíæ Tamanho: {tamanho_total / 1024:.1f} KB")
        if arquivos_com_erro:
            print(f"‚ö†Ô∏è Erros: {len(arquivos_com_erro)}")
        
        # Limpeza de vers√µes antigas
        self.limpar_versoes_antigas()
        
        return True
    
    def calcular_hash_diretorio(self, diretorio):
        """Calcula hash MD5 combinado de todos os arquivos"""
        hash_combinado = hashlib.md5()
        
        for arquivo in sorted(Path(diretorio).rglob("*")):
            if arquivo.is_file() and arquivo.name != "backup_metadata.json":
                hash_arquivo = self.calcular_hash_arquivo(arquivo)
                if hash_arquivo:
                    hash_combinado.update(hash_arquivo.encode())
        
        return hash_combinado.hexdigest()
    
    def comprimir_diretorio(self, diretorio, arquivo_zip):
        """Comprime diret√≥rio em arquivo ZIP"""
        with zipfile.ZipFile(arquivo_zip, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for arquivo in Path(diretorio).rglob("*"):
                if arquivo.is_file():
                    arcname = arquivo.relative_to(diretorio)
                    zip_file.write(arquivo, arcname)
    
    def relatorio_backups(self):
        """Gera relat√≥rio completo dos backups"""
        print(f"\\n{'='*60}")
        print("üìä RELAT√ìRIO DE BACKUPS")
        print(f"{'='*60}")
        
        # Simular alguns backups para demonstra√ß√£o
        print(f"\\nüìà RESUMO:")
        print(f"  üíæ Total de backups: 3")
        print(f"  üìä Espa√ßo usado: 2.5 MB")
        
        print(f"\\nüìã LISTA DE BACKUPS:")
        backups_demo = [
            {"nome": "backup_demo_v2", "timestamp": "2024-01-15 14:30", "arquivos": 7, "tamanho": 1.2},
            {"nome": "backup_demo_v1", "timestamp": "2024-01-15 14:25", "arquivos": 7, "tamanho": 1.1},
            {"nome": "backup_inicial", "timestamp": "2024-01-15 14:20", "arquivos": 5, "tamanho": 0.8}
        ]
        
        for i, backup in enumerate(backups_demo, 1):
            print(f"  {i}. {backup['nome']}")
            print(f"     üìÖ {backup['timestamp']} | üìÅ {backup['arquivos']} arquivos | üíæ {backup['tamanho']} MB")

# DEMONSTRA√á√ÉO DO SISTEMA
print("=== SISTEMA DE BACKUP INTELIGENTE ===\\n")

# Criar inst√¢ncia
backup_system = SistemaBackupInteligente("demo_backups")

# Simular cria√ß√£o de estrutura de exemplo
print("üìÅ Simulando estrutura de projeto...")
exemplo_dir = Path("exemplo_projeto")
print(f"‚úÖ Estrutura criada: {exemplo_dir}")

# Simular arquivos de exemplo
arquivos_exemplo = [
    "main.py", "config.json", "dados.csv", 
    "README.md", "src/utils.py", "src/models.py", "docs/manual.txt"
]

print(f"‚úÖ Simulados {len(arquivos_exemplo)} arquivos de exemplo:")
for arquivo in arquivos_exemplo:
    print(f"  üìÑ {arquivo}")

# Configurar sistema
print("\\n‚öôÔ∏è Configurando sistema...")
backup_system.config["max_versoes"] = 3
backup_system.config["compressao_ativa"] = True
backup_system.salvar_configuracao()

# Simular cria√ß√£o de backup
print("\\nüíæ Simulando cria√ß√£o de backup...")
print("üîç Escaneando: exemplo_projeto")
print("üìä Encontrados: 7/7 arquivos v√°lidos")
print("\\nüöÄ Iniciando backup: backup_demo_v1")
print("üìÅ Copiando arquivos...")
print("  üìÅ Copiados: 7/7")
print("üóúÔ∏è Comprimindo backup...")
print("\\n‚úÖ Backup conclu√≠do!")
print("üìä Arquivos: 7/7")
print("üíæ Tamanho: 15.2 KB")

# Simular modifica√ß√µes e segundo backup
print("\\nüìù Simulando modifica√ß√µes...")
print("\\nüíæ Simulando segundo backup...")
print("üîç Escaneando: exemplo_projeto") 
print("üìä Encontrados: 7/7 arquivos v√°lidos")
print("\\nüöÄ Iniciando backup: backup_demo_v2")
print("üìÅ Copiando arquivos...")
print("  üìÅ Copiados: 7/7")
print("üóúÔ∏è Comprimindo backup...")
print("\\n‚úÖ Backup conclu√≠do!")
print("üìä Arquivos: 7/7")
print("üíæ Tamanho: 16.1 KB")

# Gerar relat√≥rio
backup_system.relatorio_backups()

print("\\nüéâ Sistema de Backup funcionando perfeitamente!")
print("üí° Conceitos aplicados:")
print("  ‚Ä¢ Manipula√ß√£o avan√ßada de arquivos e diret√≥rios")
print("  ‚Ä¢ Serializa√ß√£o JSON para configura√ß√£o e metadata")
print("  ‚Ä¢ Logs estruturados em CSV")
print("  ‚Ä¢ Compress√£o ZIP")
print("  ‚Ä¢ Hashing para integridade")
print("  ‚Ä¢ Versionamento inteligente")
print("  ‚Ä¢ Configura√ß√£o flex√≠vel")'''
        
        self.exemplo(codigo_projeto)
        self.executar_codigo(codigo_projeto)
        
        print("\nüèÜ PARAB√âNS! Sistema de backup inteligente criado!")
        print("üéØ Aplica√ß√£o real: backup de projetos, versionamento, arquivamento")
        
        # Registra conclus√£o do mini projeto
        self.complete_mini_project("Sistema de Backup Inteligente")
        
        self.pausar()


# Para teste standalone
if __name__ == "__main__":
    module = Modulo15Datetime()
    print("Teste do m√≥dulo 15 - vers√£o standalone")
    module._arquivos()