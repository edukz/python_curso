#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Controlador do Curso
Gerencia a l√≥gica principal de execu√ß√£o do curso
"""

import time
from typing import Dict, Any, Optional, Callable, Tuple
from datetime import datetime

from ..progress_manager import ProgressManager
from ..visual_feedback import VisualFeedback
from ..logger import CourseLogger
from ..gamification_system import GamificationSystem
from ..ui_components import UIComponents
from ..error_tracker import ErrorTracker
from ..review_mode import ReviewMode
from ..glossary import Glossary
from ..certificate_generator import CertificateGenerator
from ..interactive_demos import InteractiveDemoSession
from ..adaptive_exercises import AdaptiveExerciseSession
from ..visual_debugger import DebugSession
from ..learning_analytics import LearningAnalytics
from ..exercises.interactive_exercises import InteractiveExerciseSession


class CourseController:
    """Controla a execu√ß√£o e l√≥gica do curso"""
    
    def __init__(self, components: Dict[str, Any]):
        """Inicializa com componentes necess√°rios"""
        self.progress = components['progress']
        self.visual = components['visual']
        self.logger = components['logger']
        self.gamification = components['gamification']
        self.ui = components['ui']
        self.error_tracker = components['error_tracker']
        self.review = components['review']
        self.glossary = components['glossary']
        self.certificate = components['certificate']
        self.interactive_demos = components['interactive_demos']
        self.adaptive_session = components['adaptive_session']
        self.debug_session = components['debug_session']
        self.analytics = components['analytics']
        self.tutor = components['tutor']
        
        # Novos componentes avan√ßados
        self.advanced_analytics = components.get('advanced_analytics')
        self.analytics_dashboard = components.get('analytics_dashboard')
        self.connectivity_manager = components.get('connectivity_manager')
        self.offline_manager = components.get('offline_manager')
        self.offline_sync = components.get('offline_sync')
        
        self.menu_options = components['menu_options']
        self.navigation = components.get('navigation')
    
    def execute_module(self, module_key: str) -> bool:
        """
        Executa um m√≥dulo do curso
        
        Args:
            module_key: Chave do m√≥dulo (ex: "1", "2", etc)
            
        Returns:
            True se deve continuar, False se deve sair
        """
        if module_key not in self.menu_options:
            return True
        
        module_id = f"modulo_{module_key}"
        nome_modulo = self.menu_options[module_key][1]
        
        # Adiciona √† navega√ß√£o se dispon√≠vel
        if self.navigation:
            self.navigation.push(nome_modulo, f"M√≥dulo {module_key}", level=1)
        
        # Log e marca in√≠cio do m√≥dulo
        self.logger.log_module_start(module_id, nome_modulo)
        self.error_tracker.start_module(module_id)
        start_time = time.time()
        
        # Executa o m√≥dulo
        funcao, _ = self.menu_options[module_key]
        funcao()
        
        # Remove da navega√ß√£o ao terminar
        if self.navigation:
            self.navigation.pop()
        
        # Calcula tempo gasto
        time_spent = int(time.time() - start_time)
        self.progress.update_module_progress(module_id, time_spent, 1)
        
        # Marca como completo se n√£o estava
        if module_id not in self.progress.progress_data["modules_completed"]:
            pontos = 100  # Pontos por completar m√≥dulo
            self.progress.mark_module_completed(module_id, pontos)
            self.visual.celebration()
            self.visual.add_score(pontos, "M√≥dulo completo!")
            self.logger.log_module_completion(module_id, pontos, time_spent)
            
            # Sistema de gamifica√ß√£o
            xp_result = self.gamification.adicionar_xp(pontos, f"M√≥dulo {module_key} completo")
            
            # Verifica badges por completar m√≥dulo
            module_stats = self.error_tracker.end_module(module_id)
            badges_novos = self.gamification.verificar_conquistas_modulo(
                module_id, 
                sem_erros=module_stats["sem_erros"],
                tempo_segundos=time_spent
            )
            
            # Exibe notifica√ß√µes
            self._show_notifications(xp_result, badges_novos)
        
        return True
    
    def _show_notifications(self, xp_result: Dict[str, Any], badges: list) -> None:
        """Exibe notifica√ß√µes de XP e badges"""
        # Notifica√ß√£o de n√≠vel
        if xp_result["subiu_nivel"]:
            self.ui.alert(
                f"üéâ LEVEL UP! Agora voc√™ √© {xp_result['nivel_atual']}!\n"
                f"‚ú® Novo t√≠tulo: {xp_result['titulo']}\n"
                f"üéØ XP para pr√≥ximo n√≠vel: {xp_result['xp_para_proximo']}",
                "‚¨ÜÔ∏è",
                "success"
            )
        
        # Notifica√ß√µes de badges
        for badge in badges:
            self.ui.alert(
                f"üèÜ NOVA CONQUISTA DESBLOQUEADA!\n"
                f"{badge['emoji']} {badge['nome']}\n"
                f"üìù {badge['descricao']}",
                "üéñÔ∏è",
                "achievement"
            )
    
    def show_progress(self) -> None:
        """Exibe o progresso detalhado do aluno"""
        self.ui.clear_screen()
        summary = self.progress.get_detailed_progress_summary()
        
        # Cabe√ßalho
        self.ui.header(
            "üìä SEU PROGRESSO DETALHADO",
            f"Aluno: {summary['user_name']} | Total: {summary['completion_percentage']:.1f}%"
        )
        
        # Estat√≠sticas gerais
        self._display_general_stats(summary)
        
        # Progresso por m√≥dulo
        self._display_module_progress()
        
        # Estat√≠sticas de gamifica√ß√£o
        self._display_gamification_stats()
        
        # Mini projetos
        self._display_mini_projects_progress(summary)
        
        # Analytics
        self._display_analytics()
        
        input("\nüî∏ Pressione ENTER para voltar ao menu...")
    
    def _display_general_stats(self, summary: Dict[str, Any]) -> None:
        """Exibe estat√≠sticas gerais"""
        stats_box = self.ui.create_box(
            "Estat√≠sticas Gerais",
            f"üìö M√≥dulos Completos: {summary['modules_completed']}/{summary['total_modules']}\n"
            f"üéØ Pontua√ß√£o Total: {summary['total_score']} pontos\n"
            f"üèÜ Conquistas: {summary['achievements']}\n"
            f"‚è±Ô∏è Tempo Total: {summary['total_time_spent'] // 60} minutos",
            "üìä"
        )
        print(stats_box)
    
    def _display_module_progress(self) -> None:
        """Exibe progresso detalhado por m√≥dulo"""
        print("\nüìö PROGRESSO POR M√ìDULO:")
        print("=" * 60)
        
        modules_progress = self.progress.progress_data["modules_progress"]
        
        for module_id in sorted(modules_progress.keys(), 
                               key=lambda x: int(x.split('_')[1]) if x.split('_')[1].isdigit() else 999):
            if not module_id.startswith("modulo_"):
                continue
                
            module_data = modules_progress[module_id]
            module_num = module_id.replace("modulo_", "")
            
            if module_data["completed"]:
                status = "‚úÖ Completo"
                color = "green"
            else:
                status = "‚è≥ Pendente"
                color = "yellow"
            
            print(f"{module_num:>3}. {status:<15} "
                  f"Pontos: {module_data['score']:>4} | "
                  f"Tentativas: {module_data['attempts']:>2}")
    
    def _display_gamification_stats(self) -> None:
        """Exibe estat√≠sticas de gamifica√ß√£o"""
        game_stats = self.gamification.get_estatisticas()
        
        game_box = self.ui.create_box(
            "Sistema de Gamifica√ß√£o",
            f"üéÆ N√≠vel: {game_stats['nivel']} - {game_stats['ranking']}\n"
            f"‚≠ê XP: {game_stats['xp_atual']}/{game_stats['xp_proximo_nivel']}\n"
            f"üìä Progresso do N√≠vel: {game_stats['progresso_nivel']:.1f}%\n"
            f"üèÖ Badges Conquistados: {game_stats['badges']}",
            "üéÆ"
        )
        print(game_box)
    
    def _display_mini_projects_progress(self, summary: Dict[str, Any]) -> None:
        """Exibe progresso dos mini projetos"""
        if "mini_projetos_completos" in summary:
            projects_box = self.ui.create_box(
                "Mini Projetos",
                f"üöÄ Projetos Completos: {summary['mini_projetos_completos']}/{summary.get('total_mini_projects', 18)}\n"
                f"üìà Progresso: {summary.get('mini_projetos_percentage', 0):.1f}%",
                "üöÄ"
            )
            print(projects_box)
    
    def _display_analytics(self) -> None:
        """Exibe analytics de aprendizado"""
        insights = self.analytics.get_learning_insights()
        
        if insights['strongest_topics']:
            print("\nüí™ SEUS PONTOS FORTES:")
            for topic in insights['strongest_topics'][:3]:
                print(f"  ‚Ä¢ {topic}")
        
        if insights['needs_practice']:
            print("\nüìö PRECISA PRATICAR:")
            for topic in insights['needs_practice'][:3]:
                print(f"  ‚Ä¢ {topic}")
    
    def handle_special_features(self, choice: str) -> bool:
        """
        Gerencia recursos especiais
        
        Args:
            choice: Escolha do usu√°rio
            
        Returns:
            True se tratou a op√ß√£o, False caso contr√°rio
        """
        choice = choice.upper()
        
        if choice == "V":
            self.interactive_demos.start_demo_session()
            return True
        elif choice == "E":
            self._show_exercise_menu()
            return True
        elif choice == "D":
            self.debug_session.start_debug_session()
            return True
        elif choice == "R":
            self.review.start_review_session()
            return True
        elif choice == "G":
            self.glossary.show_glossary_menu()
            return True
        elif choice == "P":
            self.show_progress()
            return True
        elif choice == "C":
            self._generate_certificate()
            return True
        elif choice == "A":
            self.tutor.start_interactive_session()
            return True
        elif choice == "S":
            self._show_analytics_dashboard()
            return True
        elif choice == "O":
            self._show_offline_status()
            return True
        
        return False
    
    def _generate_certificate(self) -> None:
        """Gera certificado se eleg√≠vel"""
        completion = self.progress.get_completion_percentage()
        
        if completion >= 80:
            user_name = self.progress.progress_data.get("user_name", "")
            if not user_name:
                user_name = input("Digite seu nome completo para o certificado: ")
                self.progress.set_user_name(user_name)
            
            filename = self.certificate.generate(
                user_name,
                completion,
                self.progress.progress_data["total_score"]
            )
            
            self.ui.success(
                f"üéì Certificado gerado com sucesso!\n"
                f"üìÑ Arquivo: {filename}"
            )
        else:
            self.ui.warning(
                f"‚ö†Ô∏è Voc√™ precisa completar pelo menos 80% do curso.\n"
                f"üìä Progresso atual: {completion:.1f}%\n"
                f"üìö Continue estudando!"
            )
            
    def _show_exercise_menu(self) -> None:
        """Mostra menu de tipos de exerc√≠cios"""
        self.ui.clear_screen()
        self.ui.header("üß† CENTRAL DE EXERC√çCIOS", "Escolha seu tipo de treino")
        
        print("\nüìö TIPOS DE EXERC√çCIOS DISPON√çVEIS:")
        print("1. üî• Exerc√≠cios Ricos (Debugging, Completion, Output, Refactoring)")
        print("2. üéØ Exerc√≠cios Adaptativos (Sistema cl√°ssico)")
        print("3. üìã Exerc√≠cios por M√≥dulo")
        print("0. üîô Voltar")
        
        escolha = input("\nüëâ Escolha o tipo de exerc√≠cio: ").strip()
        
        if escolha == "1":
            # Exerc√≠cios ricos
            rich_session = InteractiveExerciseSession(self.ui, self.progress, self.visual)
            rich_session.start_rich_exercise_session()
        elif escolha == "2":
            # Sistema adaptativo original
            self.adaptive_session.start_session()
        elif escolha == "3":
            self._show_module_exercises()
        # Escolha "0" ou inv√°lida volta automaticamente
        
    def _show_module_exercises(self) -> None:
        """Mostra exerc√≠cios organizados por m√≥dulo"""
        from ..exercises.exercise_bank import ExerciseBank
        
        self.ui.clear_screen()
        self.ui.header("üìã EXERC√çCIOS POR M√ìDULO", "Pratique conceitos espec√≠ficos")
        
        print("\nüìö M√ìDULOS DISPON√çVEIS:")
        modules = [
            (1, "Introdu√ß√£o ao Python"),
            (2, "Primeiro Programa"),
            (3, "Vari√°veis"),
            (4, "Tipos de Dados"),
            (7, "Condi√ß√µes (if/else)"),
            (8, "Repeti√ß√µes (loops)"),
            (9, "Listas"),
            (10, "Fun√ß√µes")
        ]
        
        for num, name in modules:
            exercises = ExerciseBank.get_exercises_by_module(num)
            count = len(exercises)
            print(f"{num:2d}. {name} ({count} exerc√≠cios)")
            
        print("0. üîô Voltar")
        
        try:
            escolha = int(input("\nüëâ Escolha o m√≥dulo: "))
            if escolha in [m[0] for m in modules]:
                self._practice_module_exercises(escolha)
        except ValueError:
            pass  # Volta ao menu automaticamente
            
    def _practice_module_exercises(self, module_num: int) -> None:
        """Pratica exerc√≠cios de um m√≥dulo espec√≠fico"""
        from ..exercises.exercise_bank import ExerciseBank
        from ..exercises.rich_exercises import RichExerciseEngine
        
        exercises = ExerciseBank.get_exercises_by_module(module_num)
        if not exercises:
            self.ui.error("Nenhum exerc√≠cio dispon√≠vel para este m√≥dulo ainda.")
            self.ui.pause()
            return
            
        engine = RichExerciseEngine(self.ui)
        current_exercise = 0
        
        while current_exercise < len(exercises):
            exercise = exercises[current_exercise]
            
            self.ui.clear_screen()
            self.ui.header(f"üìù M√ìDULO {module_num} - EXERC√çCIO {current_exercise + 1}/{len(exercises)}", 
                          exercise.title)
            
            # Executa exerc√≠cio baseado no tipo
            if exercise.type.value == "debugging":
                success = self._do_single_debugging(exercise, engine)
            elif exercise.type.value == "code_completion":
                success = self._do_single_completion(exercise, engine)
            elif exercise.type.value == "output_prediction":
                success = self._do_single_output(exercise, engine)
            elif exercise.type.value == "code_refactoring":
                success = self._do_single_refactoring(exercise, engine)
            else:
                success = False
                
            # Navega√ß√£o
            print("\n" + "="*50)
            print("üîÑ OP√á√ïES:")
            if current_exercise > 0:
                print("P. ‚Üê Exerc√≠cio anterior")
            if current_exercise < len(exercises) - 1:
                print("N. ‚Üí Pr√≥ximo exerc√≠cio")
            print("M. üìã Voltar ao menu de m√≥dulos")
            print("Q. üè† Voltar ao menu principal")
            
            nav = input("\nüëâ Escolha: ").upper()
            
            if nav == "P" and current_exercise > 0:
                current_exercise -= 1
            elif nav == "N" and current_exercise < len(exercises) - 1:
                current_exercise += 1
            elif nav == "M":
                break
            elif nav == "Q":
                return
            else:
                current_exercise += 1  # Avan√ßa por padr√£o
                
    def _do_single_debugging(self, exercise, engine) -> bool:
        """Executa um exerc√≠cio de debugging √∫nico"""
        print(f"üêõ {exercise.description}")
        print(f"‚≠ê Dificuldade: {'‚≠ê' * exercise.difficulty} | üí∞ {exercise.points} pontos")
        
        print("\nüìÑ C√ìDIGO COM BUG:")
        print("=" * 40)
        self._display_code_lines(exercise.code)
        print("=" * 40)
        
        print("\n‚úèÔ∏è Digite o c√≥digo corrigido (linha vazia para terminar):")
        user_code = self._get_multiline_input()
        
        if user_code.strip():
            correct, feedback, points = engine.evaluate_exercise(exercise, user_code)
            print(f"\nüìä RESULTADO: {feedback}")
            
            if correct:
                self.progress.add_points("rich_exercises", points)
                return True
                
        return False
        
    def _do_single_completion(self, exercise, engine) -> bool:
        """Executa um exerc√≠cio de code completion √∫nico"""
        print(f"üìù {exercise.description}")
        print(f"‚≠ê Dificuldade: {'‚≠ê' * exercise.difficulty} | üí∞ {exercise.points} pontos")
        
        # Mostra c√≥digo com placeholders numerados
        display_code = exercise.code
        for i, (key, _) in enumerate(exercise.placeholders.items(), 1):
            display_code = display_code.replace("_____", f"__[{i}]__", 1)
            
        print("\nüìÑ C√ìDIGO INCOMPLETO:")
        print("=" * 40)
        self._display_code_lines(display_code)
        print("=" * 40)
        
        # Coleta respostas
        print("\n‚úèÔ∏è COMPLETE OS ESPA√áOS:")
        user_answers = {}
        for i, (key, _) in enumerate(exercise.placeholders.items(), 1):
            answer = input(f"  [{i}] ‚Üí ").strip()
            user_answers[key] = answer
            
        correct, feedback, points = engine.evaluate_exercise(exercise, user_answers)
        print(f"\nüìä RESULTADO: {feedback}")
        
        if points > 0:
            self.progress.add_points("rich_exercises", points)
            return correct
            
        return False
        
    def _do_single_output(self, exercise, engine) -> bool:
        """Executa um exerc√≠cio de output prediction √∫nico"""
        print(f"üîÆ {exercise.description}")
        print(f"‚≠ê Dificuldade: {'‚≠ê' * exercise.difficulty} | üí∞ {exercise.points} pontos")
        
        print("\nüìÑ C√ìDIGO:")
        print("=" * 40)
        self._display_code_lines(exercise.code)
        print("=" * 40)
        
        print("\n‚úèÔ∏è QUAL SER√Å O OUTPUT? (linha vazia para terminar)")
        user_output = self._get_multiline_input()
        
        correct, feedback, points = engine.evaluate_exercise(exercise, user_output)
        print(f"\nüìä RESULTADO: {feedback}")
        
        if correct:
            self.progress.add_points("rich_exercises", points)
            return True
            
        return False
        
    def _do_single_refactoring(self, exercise, engine) -> bool:
        """Executa um exerc√≠cio de refactoring √∫nico"""
        print(f"üîß {exercise.description}")
        print(f"‚≠ê Dificuldade: {'‚≠ê' * exercise.difficulty} | üí∞ {exercise.points} pontos")
        
        print("\nüìÑ C√ìDIGO ORIGINAL:")
        print("=" * 40)
        self._display_code_lines(exercise.code)
        print("=" * 40)
        
        print("\nüéØ CRIT√âRIOS:")
        for criterion in exercise.refactoring_criteria:
            print(f"  ‚Ä¢ {criterion}")
            
        print("\n‚úèÔ∏è Digite o c√≥digo refatorado (linha vazia para terminar):")
        user_code = self._get_multiline_input()
        
        if user_code.strip():
            correct, feedback, points = engine.evaluate_exercise(exercise, user_code)
            print(f"\nüìä RESULTADO: {feedback}")
            
            if points > 0:
                self.progress.add_points("rich_exercises", points)
                return correct
                
        return False
        
    def _display_code_lines(self, code: str):
        """Exibe c√≥digo com numera√ß√£o"""
        for i, line in enumerate(code.strip().split('\n'), 1):
            print(f"{i:3d} | {line}")
            
    def _get_multiline_input(self) -> str:
        """Coleta input de m√∫ltiplas linhas"""
        lines = []
        while True:
            try:
                line = input()
                if line == "":
                    break
                lines.append(line)
            except EOFError:
                break
        return '\n'.join(lines)
    
    def _show_analytics_dashboard(self) -> None:
        """Mostra dashboard de analytics avan√ßados"""
        if self.analytics_dashboard:
            try:
                self.analytics_dashboard.show_main_dashboard()
            except Exception as e:
                self.ui.error(f"Erro ao abrir analytics: {str(e)}")
                self.ui.pause()
        else:
            self.ui.error("Sistema de analytics n√£o dispon√≠vel")
            self.ui.pause()
    
    def _show_offline_status(self) -> None:
        """Mostra status de conectividade e modo offline"""
        if not self.connectivity_manager or not self.offline_manager:
            self.ui.error("Sistemas offline n√£o dispon√≠veis")
            self.ui.pause()
            return
            
        self.ui.clear_screen()
        self.ui.header("üåê STATUS DE CONECTIVIDADE", "Modo Offline e Sincroniza√ß√£o")
        
        # Status de conectividade
        conn_quality = self.connectivity_manager.get_connection_quality()
        status_icon = {
            "online": "üü¢",
            "offline": "üî¥", 
            "limited": "üü°",
            "unknown": "‚ö™"
        }
        
        print(f"\nüåê CONECTIVIDADE:")
        print(f"  Status: {status_icon.get(conn_quality['status'], '‚ùì')} {conn_quality['status'].upper()}")
        print(f"  Qualidade: {conn_quality['quality']:.1f}%")
        if conn_quality.get('avg_latency_ms'):
            print(f"  Lat√™ncia: {conn_quality['avg_latency_ms']:.0f}ms")
        print(f"  Estabilidade: {conn_quality['stability']:.1f}%")
        
        # Status do cache offline
        offline_status = self.offline_manager.get_offline_status()
        print(f"\nüíæ MODO OFFLINE:")
        ready_icon = "‚úÖ" if offline_status['ready'] else "‚ö†Ô∏è"
        print(f"  Status: {ready_icon} {'Pronto' if offline_status['ready'] else 'N√£o configurado'}")
        print(f"  Recursos dispon√≠veis: {len(offline_status['available_resources'])}/5")
        print(f"  Cache: {offline_status['cache_size_mb']:.1f}MB ({offline_status['cached_items']} itens)")
        
        # Status de sincroniza√ß√£o (se dispon√≠vel)
        if self.offline_sync:
            sync_status = self.offline_sync.get_sync_status()
            print(f"\nüîÑ SINCRONIZA√á√ÉO:")
            print(f"  Status: {sync_status['current_status'].upper()}")
            print(f"  Opera√ß√µes pendentes: {sync_status['pending_operations']}")
            print(f"  Auto-sync: {'‚úÖ Ativado' if sync_status['auto_sync_enabled'] else '‚ùå Desativado'}")
            if sync_status['last_sync']:
                from datetime import datetime
                last_sync = datetime.fromisoformat(sync_status['last_sync'])
                print(f"  √öltima sync: {last_sync.strftime('%d/%m/%Y %H:%M')}")
        
        print(f"\nüí° DICA: Use 'O' no menu principal para acessar op√ß√µes de sincroniza√ß√£o")
        self.ui.pause()